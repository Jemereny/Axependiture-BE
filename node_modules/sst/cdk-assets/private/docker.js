import * as fs from "fs";
import * as os from "os";
import * as path from "path";
import { cdkCredentialsConfig, obtainEcrCredentials, } from "cdk-assets/lib/private/docker-credentials.js";
import { shell, } from "cdk-assets/lib/private/shell.js";
import { createCriticalSection } from "cdk-assets/lib/private/util.js";
var InspectImageErrorCode;
(function (InspectImageErrorCode) {
    InspectImageErrorCode[InspectImageErrorCode["Docker"] = 1] = "Docker";
    InspectImageErrorCode[InspectImageErrorCode["Podman"] = 125] = "Podman";
})(InspectImageErrorCode || (InspectImageErrorCode = {}));
export class Docker {
    logger;
    configDir = undefined;
    constructor(logger) {
        this.logger = logger;
    }
    /**
     * Whether an image with the given tag exists
     */
    async exists(tag) {
        try {
            await this.execute(["inspect", tag], { quiet: true });
            return true;
        }
        catch (e) {
            const error = e;
            /**
             * The only error we expect to be thrown will have this property and value.
             * If it doesn't, it's unrecognized so re-throw it.
             */
            if (error.code !== "PROCESS_FAILED") {
                throw error;
            }
            /**
             * If we know the shell command above returned an error, check to see
             * if the exit code is one we know to actually mean that the image doesn't
             * exist.
             */
            switch (error.exitCode) {
                case InspectImageErrorCode.Docker:
                case InspectImageErrorCode.Podman:
                    // Docker and Podman will return this exit code when an image doesn't exist, return false
                    // context: https://github.com/aws/aws-cdk/issues/16209
                    return false;
                default:
                    // This is an error but it's not an exit code we recognize, throw.
                    throw error;
            }
        }
    }
    async build(options) {
        const buildCommand = [
            "build",
            ...flatten(Object.entries(options.buildArgs || {}).map(([k, v]) => [
                "--build-arg",
                `${k}=${v}`,
            ])),
            ...flatten(Object.entries(options.buildSecrets || {}).map(([k, v]) => [
                "--secret",
                `id=${k},${v}`,
            ])),
            "--tag",
            options.tag,
            ...(options.target ? ["--target", options.target] : []),
            ...(options.file ? ["--file", options.file] : []),
            ...(options.networkMode ? ["--network", options.networkMode] : []),
            ...(options.platform ? ["--platform", options.platform] : []),
            ...(options.outputs
                ? options.outputs.map((output) => [`--output=${output}`])
                : []),
            ...(options.cacheFrom
                ? [
                    ...options.cacheFrom
                        .map((cacheFrom) => [
                        "--cache-from",
                        this.cacheOptionToFlag(cacheFrom),
                    ])
                        .flat(),
                ]
                : []),
            ...(options.cacheTo
                ? ["--cache-to", this.cacheOptionToFlag(options.cacheTo)]
                : []),
            ".",
        ];
        await this.execute(buildCommand, {
            cwd: options.directory,
            // TODO: remove after PR is merged
            quiet: options.quiet,
        });
    }
    /**
     * Get credentials from ECR and run docker login
     */
    async login(ecr) {
        const credentials = await obtainEcrCredentials(ecr);
        // Use --password-stdin otherwise docker will complain. Loudly.
        await this.execute([
            "login",
            "--username",
            credentials.username,
            "--password-stdin",
            credentials.endpoint,
        ], {
            input: credentials.password,
            // Need to quiet otherwise Docker will complain
            // 'WARNING! Your password will be stored unencrypted'
            // doesn't really matter since it's a token.
            quiet: true,
        });
    }
    async tag(sourceTag, targetTag) {
        await this.execute(["tag", sourceTag, targetTag]);
    }
    // TODO: remove after PR is merged
    async push(options) {
        await this.execute(["push", options.tag], { quiet: options.quiet });
    }
    /**
     * If a CDK Docker Credentials file exists, creates a new Docker config directory.
     * Sets up `docker-credential-cdk-assets` to be the credential helper for each domain in the CDK config.
     * All future commands (e.g., `build`, `push`) will use this config.
     *
     * See https://docs.docker.com/engine/reference/commandline/login/#credential-helpers for more details on cred helpers.
     *
     * @returns true if CDK config was found and configured, false otherwise
     */
    configureCdkCredentials() {
        const config = cdkCredentialsConfig();
        if (!config) {
            return false;
        }
        this.configDir = fs.mkdtempSync(path.join(os.tmpdir(), "cdkDockerConfig"));
        const domains = Object.keys(config.domainCredentials);
        const credHelpers = domains.reduce((map, domain) => {
            map[domain] = "cdk-assets"; // Use docker-credential-cdk-assets for this domain
            return map;
        }, {});
        fs.writeFileSync(path.join(this.configDir, "config.json"), JSON.stringify({ credHelpers }), { encoding: "utf-8" });
        return true;
    }
    /**
     * Removes any configured Docker config directory.
     * All future commands (e.g., `build`, `push`) will use the default config.
     *
     * This is useful after calling `configureCdkCredentials` to reset to default credentials.
     */
    resetAuthPlugins() {
        this.configDir = undefined;
    }
    async execute(args, options = {}) {
        const configArgs = this.configDir ? ["--config", this.configDir] : [];
        // TODO: remove after PR is merged
        //const pathToCdkAssets = path.resolve(__dirname, "..", "..", "bin");
        const pathToCdkAssets = "";
        try {
            await shell([getDockerCmd(), ...configArgs, ...args], {
                logger: this.logger,
                ...options,
                env: {
                    ...process.env,
                    ...options.env,
                    PATH: `${pathToCdkAssets}${path.delimiter}${options.env?.PATH ?? process.env.PATH}`,
                },
            });
        }
        catch (e) {
            if (e.code === "ENOENT") {
                throw new Error("Unable to execute 'docker' in order to build a container asset. Please install 'docker' and try again.");
            }
            throw e;
        }
    }
    cacheOptionToFlag(option) {
        let flag = `type=${option.type}`;
        if (option.params) {
            flag +=
                "," +
                    Object.entries(option.params)
                        .map(([k, v]) => `${k}=${v}`)
                        .join(",");
        }
        return flag;
    }
}
/**
 * Helps get appropriately configured Docker instances during the container
 * image publishing process.
 */
export class DockerFactory {
    enterLoggedInDestinationsCriticalSection = createCriticalSection();
    loggedInDestinations = new Set();
    /**
     * Gets a Docker instance for building images.
     */
    async forBuild(options) {
        const docker = new Docker(options.logger);
        // Default behavior is to login before build so that the Dockerfile can reference images in the ECR repo
        // However, if we're in a pipelines environment (for example),
        // we may have alternative credentials to the default ones to use for the build itself.
        // If the special config file is present, delay the login to the default credentials until the push.
        // If the config file is present, we will configure and use those credentials for the build.
        let cdkDockerCredentialsConfigured = docker.configureCdkCredentials();
        if (!cdkDockerCredentialsConfigured) {
            await this.loginOncePerDestination(docker, options);
        }
        return docker;
    }
    /**
     * Gets a Docker instance for pushing images to ECR.
     */
    async forEcrPush(options) {
        const docker = new Docker(options.logger);
        await this.loginOncePerDestination(docker, options);
        return docker;
    }
    async loginOncePerDestination(docker, options) {
        // Changes: 012345678910.dkr.ecr.us-west-2.amazonaws.com/tagging-test
        // To this: 012345678910.dkr.ecr.us-west-2.amazonaws.com
        const repositoryDomain = options.repoUri.split("/")[0];
        // Ensure one-at-a-time access to loggedInDestinations.
        await this.enterLoggedInDestinationsCriticalSection(async () => {
            if (this.loggedInDestinations.has(repositoryDomain)) {
                return;
            }
            await docker.login(options.ecr);
            this.loggedInDestinations.add(repositoryDomain);
        });
    }
}
function getDockerCmd() {
    return process.env.CDK_DOCKER ?? "docker";
}
function flatten(x) {
    return Array.prototype.concat([], ...x);
}
