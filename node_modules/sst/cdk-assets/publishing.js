import { DockerFactory } from "./private/docker.js";
import { makeAssetHandler } from "./private/handlers/index.js";
import { EventType, } from "cdk-assets/lib/progress.js";
export class AssetPublishing {
    manifest;
    options;
    /**
     * The message for the IPublishProgress interface
     */
    message = "Starting";
    /**
     * The current asset for the IPublishProgress interface
     */
    currentAsset;
    failures = new Array();
    assets;
    totalOperations;
    completedOperations = 0;
    aborted = false;
    handlerHost;
    publishInParallel;
    buildAssets;
    publishAssets;
    handlerCache = new Map();
    constructor(manifest, options) {
        this.manifest = manifest;
        this.options = options;
        this.assets = manifest.entries;
        this.totalOperations = this.assets.length;
        this.publishInParallel = options.publishInParallel ?? false;
        this.buildAssets = options.buildAssets ?? true;
        this.publishAssets = options.publishAssets ?? true;
        const self = this;
        this.handlerHost = {
            aws: this.options.aws,
            get aborted() {
                return self.aborted;
            },
            emitMessage(t, m) {
                self.progressEvent(t, m);
            },
            dockerFactory: new DockerFactory(),
        };
    }
    /**
     * Publish all assets from the manifest
     */
    async publish() {
        if (this.publishInParallel) {
            await Promise.all(this.assets.map(async (asset) => this.publishAsset(asset)));
        }
        else {
            for (const asset of this.assets) {
                if (!(await this.publishAsset(asset))) {
                    break;
                }
            }
        }
        if ((this.options.throwOnError ?? true) && this.failures.length > 0) {
            throw new Error(`Error publishing: ${this.failures.map((e) => e.error.message)}`);
        }
    }
    /**
     * Build a single asset from the manifest
     */
    async buildEntry(asset) {
        try {
            if (this.progressEvent(EventType.START, `Building ${asset.id}`)) {
                return false;
            }
            const handler = this.assetHandler(asset);
            await handler.build();
            if (this.aborted) {
                throw new Error("Aborted");
            }
            this.completedOperations++;
            if (this.progressEvent(EventType.SUCCESS, `Built ${asset.id}`)) {
                return false;
            }
        }
        catch (e) {
            this.failures.push({ asset, error: e });
            this.completedOperations++;
            if (this.progressEvent(EventType.FAIL, e.message)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Publish a single asset from the manifest
     */
    async publishEntry(asset) {
        try {
            if (this.progressEvent(EventType.START, `Publishing ${asset.id}`)) {
                return false;
            }
            const handler = this.assetHandler(asset);
            await handler.publish();
            if (this.aborted) {
                throw new Error("Aborted");
            }
            this.completedOperations++;
            if (this.progressEvent(EventType.SUCCESS, `Published ${asset.id}`)) {
                return false;
            }
        }
        catch (e) {
            this.failures.push({ asset, error: e });
            this.completedOperations++;
            if (this.progressEvent(EventType.FAIL, e.message)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Return whether a single asset is published
     */
    isEntryPublished(asset) {
        const handler = this.assetHandler(asset);
        return handler.isPublished();
    }
    /**
     * publish an asset (used by 'publish()')
     * @param asset The asset to publish
     * @returns false when publishing should stop
     */
    async publishAsset(asset) {
        try {
            if (this.progressEvent(EventType.START, `Publishing ${asset.id}`)) {
                return false;
            }
            const handler = this.assetHandler(asset);
            if (this.buildAssets) {
                await handler.build();
            }
            if (this.publishAssets) {
                await handler.publish();
            }
            if (this.aborted) {
                throw new Error("Aborted");
            }
            this.completedOperations++;
            if (this.progressEvent(EventType.SUCCESS, `Published ${asset.id}`)) {
                return false;
            }
        }
        catch (e) {
            this.failures.push({ asset, error: e });
            this.completedOperations++;
            if (this.progressEvent(EventType.FAIL, e.message)) {
                return false;
            }
        }
        return true;
    }
    get percentComplete() {
        if (this.totalOperations === 0) {
            return 100;
        }
        return Math.floor((this.completedOperations / this.totalOperations) * 100);
    }
    abort() {
        this.aborted = true;
    }
    get hasFailures() {
        return this.failures.length > 0;
    }
    /**
     * Publish a progress event to the listener, if present.
     *
     * Returns whether an abort is requested. Helper to get rid of repetitive code in publish().
     */
    progressEvent(event, message) {
        this.message = message;
        if (this.options.progressListener) {
            this.options.progressListener.onPublishEvent(event, this);
        }
        return this.aborted;
    }
    assetHandler(asset) {
        const existing = this.handlerCache.get(asset);
        if (existing) {
            return existing;
        }
        const ret = makeAssetHandler(this.manifest, asset, this.handlerHost, {
            // TODO: remove after PR is merged
            quiet: this.options.quiet,
        });
        this.handlerCache.set(asset, ret);
        return ret;
    }
}
