import * as cxapi from "@aws-cdk/cx-api";
import * as cdk_assets from "cdk-assets";
// TODO: remove after PR is merged
import { AssetPublishing } from "../cdk-assets/publishing.js";
import { Mode } from "sst-aws-cdk/lib/api/aws-auth/credentials.js";
import { debug, error, print } from "sst-aws-cdk/lib/logging.js";
/**
 * Use cdk-assets to publish all assets in the given manifest.
 */
export async function publishAssets(manifest, sdk, targetEnv, options = {}) {
    // This shouldn't really happen (it's a programming error), but we don't have
    // the types here to guide us. Do an runtime validation to be super super sure.
    if (targetEnv.account === undefined ||
        targetEnv.account === cxapi.UNKNOWN_ACCOUNT ||
        targetEnv.region === undefined ||
        targetEnv.account === cxapi.UNKNOWN_REGION) {
        throw new Error(`Asset publishing requires resolved account and region, got ${JSON.stringify(targetEnv)}`);
    }
    const publisher = new AssetPublishing(manifest, {
        aws: new PublishingAws(sdk, targetEnv),
        progressListener: new PublishingProgressListener(options.quiet ?? false),
        throwOnError: false,
        publishInParallel: options.parallel ?? true,
        buildAssets: options.buildAssets ?? true,
        publishAssets: true,
        // TODO: remove after PR is merged
        quiet: options.quiet,
    });
    await publisher.publish();
    if (publisher.hasFailures) {
        console.log(publisher.failures);
        throw new Error("Failed to publish one or more assets. See the error messages above for more information.");
    }
}
/**
 * Use cdk-assets to build all assets in the given manifest.
 */
export async function buildAssets(manifest, sdk, targetEnv, options = {}) {
    // This shouldn't really happen (it's a programming error), but we don't have
    // the types here to guide us. Do an runtime validation to be super super sure.
    if (targetEnv.account === undefined ||
        targetEnv.account === cxapi.UNKNOWN_ACCOUNT ||
        targetEnv.region === undefined ||
        targetEnv.account === cxapi.UNKNOWN_REGION) {
        throw new Error(`Asset building requires resolved account and region, got ${JSON.stringify(targetEnv)}`);
    }
    const publisher = new cdk_assets.AssetPublishing(manifest, {
        aws: new PublishingAws(sdk, targetEnv),
        progressListener: new PublishingProgressListener(options.quiet ?? false),
        throwOnError: false,
        publishInParallel: options.parallel ?? true,
        buildAssets: true,
        publishAssets: false,
    });
    await publisher.publish();
    if (publisher.hasFailures) {
        throw new Error("Failed to build one or more assets. See the error messages above for more information.");
    }
}
export class PublishingAws {
    aws;
    targetEnv;
    sdkCache = new Map();
    constructor(
    /**
     * The base SDK to work with
     */
    aws, 
    /**
     * Environment where the stack we're deploying is going
     */
    targetEnv) {
        this.aws = aws;
        this.targetEnv = targetEnv;
    }
    async discoverPartition() {
        return ((await this.aws.baseCredentialsPartition(this.targetEnv, Mode.ForWriting)) ?? "aws");
    }
    async discoverDefaultRegion() {
        return this.targetEnv.region;
    }
    async discoverCurrentAccount() {
        const account = await this.aws.defaultAccount();
        return (account ?? {
            accountId: "<unknown account>",
            partition: "aws",
        });
    }
    async discoverTargetAccount(options) {
        return (await this.sdk(options)).currentAccount();
    }
    async s3Client(options) {
        return (await this.sdk(options)).s3();
    }
    async ecrClient(options) {
        return (await this.sdk(options)).ecr();
    }
    async secretsManagerClient(options) {
        return (await this.sdk(options)).secretsManager();
    }
    /**
     * Get an SDK appropriate for the given client options
     */
    async sdk(options) {
        const env = {
            ...this.targetEnv,
            region: options.region ?? this.targetEnv.region, // Default: same region as the stack
        };
        const cacheKey = JSON.stringify({
            env,
            assumeRuleArn: options.assumeRoleArn,
            assumeRoleExternalId: options.assumeRoleExternalId,
            quiet: options.quiet,
        });
        const maybeSdk = this.sdkCache.get(cacheKey);
        if (maybeSdk) {
            return maybeSdk;
        }
        const sdk = (await this.aws.forEnvironment(env, Mode.ForWriting, {
            assumeRoleArn: options.assumeRoleArn,
            assumeRoleExternalId: options.assumeRoleExternalId,
        }, options.quiet)).sdk;
        this.sdkCache.set(cacheKey, sdk);
        return sdk;
    }
}
export const EVENT_TO_LOGGER = {
    build: debug,
    cached: debug,
    check: debug,
    debug,
    fail: error,
    found: debug,
    start: print,
    success: print,
    upload: debug,
};
class PublishingProgressListener {
    quiet;
    constructor(quiet) {
        this.quiet = quiet;
    }
    onPublishEvent(type, event) {
        const handler = this.quiet && type !== "fail" ? debug : EVENT_TO_LOGGER[type];
        handler(`[${event.percentComplete}%] ${type}: ${event.message}`);
    }
}
